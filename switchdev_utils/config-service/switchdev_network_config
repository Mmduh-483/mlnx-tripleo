#!/usr/bin/python


import argparse
import logging
import os
import re
import subprocess
import sys
import time
import yaml

from collections import OrderedDict

VERSION = "1.0.0"
CONF_VERSION_MAJOR = 1
CONF_VERSION_MINOR = 0
CONFIG_FILE = "/etc/switchdev-config/config.yaml"
LOG_FILE = '/var/log/switchdev_network_config.log'

SYS_CLASS_NET = '/sys/class/net'
MLNX_VENDOR_ID = "0x15b3"
CX4_DEVICE_ID = "0x1013"
CX4LX_DEVICE_ID = "0x1015"
VF_PCI_PATH = "/sys/bus/pci/devices/%(vf_pci)s/driver"
MLNX_UNBIND_FILE_PATH = "/sys/bus/pci/drivers/mlx5_core/unbind"
MLNX_BIND_FILE_PATH = "/sys/bus/pci/drivers/mlx5_core/bind"
SRIOV_BIND_CONFIG_FILE = "/var/lib/sriov_bind_config.yaml"

UDEV_RULE_FILE = '/etc/udev/rules.d/90-sriov-config.rules'
REP_LINK_NAME_FILE = "/etc/udev/rep-link-name.sh"
REP_LINK_NAME_DATA = '''#!/bin/bash
# This file is autogenerated by os-net-config
set -x
PORT="$1"
echo "NUMBER=${PORT##pf*vf}"
'''

COMMON_IFCFG_DATA = 'ONBOOT=yes\nHOTPLUG=no\nNM_CONTROLLED=' \
                    'no\nPEERDNS=no\nBOOTPROTO=none\n'
PF_FUNC_RE = re.compile(r"\.(\d+)$", 0)
MAX_RETRIES = 10

SRIOV_CONFIG_SERVICE_FILE = "/etc/systemd/system/sriov_config.service"
SRIOV_CONFIG_SERVICE_CONTENT = """[Unit]
Description=SR-IOV numvfs configuration
After=systemd-udev-settle.service openibd.service
Before=openvswitch.service network.service
[Service]
Type=oneshot
ExecStart=/etc/switchdev-config/switchdev_network_config --sriov_config
[Install]
WantedBy=multi-user.target
"""

SRIOV_BIND_SERVICE_FILE = "/etc/systemd/system/sriov_bind.service"
SRIOV_BIND_SERVICE_CONTENT = """[Unit]
Description=SR-IOV vfs binding
After=network.service sriov_config.service
[Service]
Type=oneshot
ExecStart=/etc/switchdev-config/switchdev_network_config --sriov_bind
[Install]
WantedBy=multi-user.target
"""
# Map of all net devices and their ifcfg files
ifcfg_interfaces_map = OrderedDict()
mlnx_vfs_pci_list = []

logging.basicConfig(filename=LOG_FILE,
                    format='%(asctime)s %(levelname)-8s %(message)s',
                    level=logging.INFO,
                    datefmt='%Y-%m-%d %H:%M:%S')
logger = logging.getLogger(__name__)


def get_file_data(filename):
    if not os.path.exists(filename):
        logger.warning("File %s does not exist" % filename)
        return ''
    try:
        with open(filename, 'r') as f:
            return f.read().strip()
    except IOError as e:
        logger.error("Error reading file: %s\n%s" % (filename, str(e)))
        return ''


def get_config():
    if os.path.exists(CONFIG_FILE):
        config_data = get_file_data(CONFIG_FILE)
        try:
            config = yaml.safe_load(config_data)
            if config:
                return config
            else:
                logger.error("No configuration is provided.. Exiting")
                exit(1)
        except yaml.YAMLError as e:
            logger.error("Error parsing config file: %s" % CONFIG_FILE)
            exit(1)
    else:
        logger.error("Configuration file does not exist.. Exiting")
        exit(1)


def run_command(*cmd):
    try:
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
        out, err = p.communicate()
        ret = p.returncode
        if ret != 0:
            err_msg = "Falied to execute %s\n%s" % (' '.join(cmd), err)
            logger.error(err_msg)
            raise RuntimeError(err_msg)
        if err:
            logger.warning("Got stderr output: %s" % err)
        logger.debug(out)
        return out
    except Exception as e:
        logger.error("Failed to execute %s\n%s" % (' '.join(cmd), str(e)))
        raise e


def get_pf_device_id(sriov_pf):
    pf_device_path = os.path.join(SYS_CLASS_NET, sriov_pf, "device/device")
    pf_device_id = get_file_data(pf_device_path).strip()
    return pf_device_id


def get_pf_pci(sriov_pf):
    pf_pci_path = os.path.join(SYS_CLASS_NET, sriov_pf, "device")
    return os.path.basename(os.readlink(pf_pci_path))


def configure_vfs_trust_switchdev(sriov_pf):
    # Configure vHCA trust for all VFs
    logger.info("Configuring vfs trust for %s vfs " % sriov_pf)
    pf_pci = get_pf_pci(sriov_pf)
    try:
        run_command('/usr/bin/mlxreg', '-d', pf_pci, '--reg_id', '0xc007',
                    '--reg_len', '0x40', '--indexes', '0x0.0:32=0x80000000',
                    '--yes', '--set', '0x4.0:32=0x1')
    except Exception as e:
        logger.error("Could not configure vfs of %s to be trusted to FW\n"
                     % (sriov_pf, str(e)))


def wait_for_uplink_rep_creation(sriov_pf):
    uplink_rep_phys_switch_id_path = "/sys/class/net/%s/phys_switch_id" \
                                     % sriov_pf

    for i in range(MAX_RETRIES):
        if get_file_data(uplink_rep_phys_switch_id_path):
            logger.info("Uplink representor %s ready", sriov_pf)
            break
        time.sleep(1)
    else:
        raise RuntimeError("Timeout while waiting for uplink representor %s.",
                           sriov_pf)


def configure_switchdev(sriov_pf):
    logger.info("Configuring switchdev for %s" % sriov_pf)
    pf_pci = get_pf_pci(sriov_pf)
    pf_device_id = get_pf_device_id(sriov_pf)
    if pf_device_id == CX4_DEVICE_ID or pf_device_id == CX4LX_DEVICE_ID:
        try:
            run_command('/usr/sbin/devlink', 'dev', 'eswitch', 'set',
                        'pci/%s' % pf_pci, 'inline-mode', 'transport')
        except Exception as e:
            logger.error("Failed to set inline-mode to transport%s" % str(e))
            raise e
    try:
        run_command('/usr/sbin/devlink', 'dev', 'eswitch', 'set',
                    'pci/%s' % pf_pci, 'mode', 'switchdev')
    except Exception as e:
        logger.error("Failed to set mode to switchdev for interface %s\n%s"
                     % (sriov_pf, str(e)))
        raise e
    logger.info("Device pci/%s set to switchdev mode." % pf_pci)
    wait_for_uplink_rep_creation(sriov_pf)


def reload_udev_rules():
    try:
        run_command('/usr/sbin/udevadm', 'control', '--reload-rules')
        logger.info("udev rules reloaded successfully")
    except Exception as e:
        logger.error("Failed to reload udev rules \n%s" % str(e))
        raise e


def write_config(filename, data, append=False):
    if append:
        with open(filename, 'a') as f:
            f.write(str(data))
    else:
        with open(filename, 'w') as f:
            f.write(str(data))


def add_udev_rule(udev_data, udev_file):
    trigger_udev_rule = False
    udev_data = udev_data.strip()
    if not os.path.exists(udev_file):
        write_config(udev_file, "%s\n" % udev_data)
        reload_udev_rules()
        trigger_udev_rule = True
    else:
        file_data = get_file_data(udev_file)
        udev_lines = file_data.split("\n")
        if udev_data not in udev_lines:
            write_config(udev_file, "%s\n" % udev_data, append=True)
            reload_udev_rules()
            trigger_udev_rule = True
    return trigger_udev_rule


def create_rep_link_name_script():
    with open(REP_LINK_NAME_FILE, "w") as f:
        f.write(REP_LINK_NAME_DATA)
    # Make the _REP_LINK_NAME_FILE executable
    os.chmod(REP_LINK_NAME_FILE, 0o755)


def add_udev_rule_to_unmanage_vf_representors_by_nm():
    udev_data_line = 'SUBSYSTEM=="net", ACTION=="add", ATTR{phys_switch_id}'\
                     '!="", ATTR{phys_port_name}=="pf*vf*", '\
                     'ENV{NM_UNMANAGED}="1"'
    return add_udev_rule(udev_data_line, UDEV_RULE_FILE)


def add_udev_rule_for_sriov_pf(sriov_pf):
    pf_pci = get_pf_pci(sriov_pf)
    udev_data_line = 'SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", '\
                     'KERNELS=="%s", NAME="%s"' % (pf_pci, sriov_pf)
    return add_udev_rule(udev_data_line, UDEV_RULE_FILE)


def trigger_udev_rules():
    try:
        run_command('/usr/sbin/udevadm', 'trigger', '--action=add',
                    '--attr-match=subsystem=net')
        logger.info("udev rules triggered successfully")
    except Exception as e:
        logger.error("Failed to trigger udev rules\n%s" % str(e))
        raise e


def add_udev_rule_for_vf_representors(sriov_pf):
    phys_switch_id_path = os.path.join(SYS_CLASS_NET, sriov_pf,
                                       "phys_switch_id")
    phys_switch_id = get_file_data(phys_switch_id_path).strip()
    pf_pci = get_pf_pci(sriov_pf)
    pf_fun_num_match = PF_FUNC_RE.search(pf_pci)
    if pf_fun_num_match:
        pf_fun_num = pf_fun_num_match.group(1)
    else:
        logger.error("Failed to get function number for %s \n"
                     "and so failed to create a udev rule for renaming "
                     "its' vf-represent" % sriov_pf)
        return

    udev_data_line = 'SUBSYSTEM=="net", ACTION=="add", ATTR{phys_switch_id}'\
                     '=="%s", ATTR{phys_port_name}=="pf%svf*", '\
                     'IMPORT{program}="%s $attr{phys_port_name}", '\
                     'NAME="%s_$env{NUMBER}"' % (phys_switch_id,
                                                 pf_fun_num,
                                                 REP_LINK_NAME_FILE,
                                                 sriov_pf)
    return add_udev_rule(udev_data_line, UDEV_RULE_FILE)


def get_numvfs(sriov_pf):
    try:
        sriov_numvfs_path = os.path.join(SYS_CLASS_NET, sriov_pf,
                                         "device/sriov_numvfs")
        with open(sriov_numvfs_path, 'r') as f:
            return int(f.read())
    except IOError as e:
        logger.error("Unable to read numvfs for %s\n%s" % (sriov_pf, str(e)))
        raise e


def get_vendor_id(ifname):
    vendor_id = get_file_data(os.path.join(SYS_CLASS_NET, ifname,
                                           "device/vendor"))
    if vendor_id:
        logger.info("Vendor ID for device %s is %s" % (ifname, vendor_id))
        return vendor_id
    else:
        logger.error("Failed to get vendor ID for device %s" % ifname)
        raise IOError("Failed to get vendor ID for device %s" % ifname)


def get_vf_pci_list(pf_name):
    vf_pci_list = []
    pf_pci_path = os.path.join(SYS_CLASS_NET, pf_name, "device")
    listOfPfFiles = os.listdir(pf_pci_path)

    for file in listOfPfFiles:
        if file.startswith("virtfn"):
            vf_pci_list.append(os.path.basename(os.readlink(
                os.path.join(pf_pci_path, file))))
    return vf_pci_list


def ifcfg_config_path(name):
    return "/etc/sysconfig/network-scripts/ifcfg-%s" % name


def write_yaml_config(filepath, data):
    with open(filepath, 'w') as f:
        yaml.safe_dump(data, f, default_flow_style=False)


def get_sriov_bind_pci_list():
    contents = get_file_data(SRIOV_BIND_CONFIG_FILE)
    sriov_bind_pci_list = yaml.safe_load(contents) if contents else {}
    return sriov_bind_pci_list


def update_sriov_bind_pci_list(sriov_bind_pci_list):
    logger.info("Updating sriov bind pci list.")
    sriov_bind_config_list = []
    try:
        sriov_bind_config_list = get_sriov_bind_pci_list()
    except Exception:
        pass
    if not sriov_bind_config_list or (
            set(sriov_bind_pci_list) != set(sriov_bind_config_list)):
        write_yaml_config(SRIOV_BIND_CONFIG_FILE, sriov_bind_pci_list)


def configure_sriov_pfs(sriov_pfs, from_sriov_service=False):
    global ifcfg_interfaces_map
    global mlnx_vfs_pci_list
    logger.info("Configuring sriov pfs..")
    trigger_udev_rule = False
    rep_link_name_script = False

    for sriov_pf in sriov_pfs:
        # Create vfs
        sriov_pf_name = sriov_pf.get("name")
        num_of_vfs = int(sriov_pf.get("numOfVfs"))

        try:
            sriov_numvfs_path = os.path.join(SYS_CLASS_NET,
                                             sriov_pf_name,
                                             "device/sriov_numvfs")
            curr_numvfs = get_numvfs(sriov_pf_name)
            if curr_numvfs == num_of_vfs:
                logger.info("Numvfs already configured for %s"
                            % sriov_pf_name)
            elif curr_numvfs != 0:
                logger.info("Numvfs for %s is different, resetting it"
                            % sriov_pf_name)
                write_config(sriov_numvfs_path, "0")
            write_config(sriov_numvfs_path, "%d" % num_of_vfs)
            logger.info("%d vfs are configured for %s" % (
                num_of_vfs, sriov_pf_name))
        except IOError as e:
            logger.error("Unable to configure pf: %s with numvfs: %d\n%s" % (
                         sriov_pf_name, num_of_vfs, str(e)))
            raise e
        # Configure switchdev mode
        vendor_id = get_vendor_id(sriov_pf_name)
        if (sriov_pf.get("switchdev") and
                vendor_id == MLNX_VENDOR_ID):
            rep_link_name_script = True
            vf_pci_list = get_vf_pci_list(sriov_pf_name)
            mlnx_vfs_pci_list += vf_pci_list
            for vf_pci in vf_pci_list:
                vf_pci_path = VF_PCI_PATH % {"vf_pci": vf_pci}
                if os.path.exists(vf_pci_path):
                    write_config(MLNX_UNBIND_FILE_PATH, "%s" % vf_pci)
                    logger.debug("Vf %s has been unbound" % vf_pci)
            add_udev_rule_to_unmanage_vf_representors_by_nm()
            trigger_udev_rule = add_udev_rule_for_sriov_pf(sriov_pf_name) \
                or trigger_udev_rule
            configure_switchdev(sriov_pf_name)
            trigger_udev_rule = add_udev_rule_for_vf_representors(
                sriov_pf_name) or trigger_udev_rule
            if sriov_pf.get("vfTrust"):
                configure_vfs_trust_switchdev(sriov_pf_name)
        if not from_sriov_service:
            sriov_pf_data = "%sDEVICE=%s\n" % (COMMON_IFCFG_DATA,
                                               sriov_pf_name)
            ifcfg_interfaces_map[sriov_pf_name] = sriov_pf_data
    if rep_link_name_script:
        create_rep_link_name_script()
    if mlnx_vfs_pci_list:
        update_sriov_bind_pci_list(mlnx_vfs_pci_list)
    if trigger_udev_rule:
        trigger_udev_rules()


def configure_sriov_config_service():
    logger.info("Configuring sriov_config service..")
    write_config(SRIOV_CONFIG_SERVICE_FILE,
                 SRIOV_CONFIG_SERVICE_CONTENT)
    run_command('systemctl', 'enable', 'sriov_config')


def configure_linux_bonds(linux_bonds):
    global ifcfg_interfaces_map
    logger.info("Configuring linux bonds..")
    for linux_bond in linux_bonds:
        bond = linux_bond.get("name")
        bond_slaves = linux_bond.get("slaves")
        bonding_options = linux_bond.get("bondingOptions")

        bonding_options_data = "BONDING_OPTS=\"%s\"\n" % bonding_options
        bond_data = "%s%sDEVICE=%s\n" % (COMMON_IFCFG_DATA,
                                         bonding_options_data,
                                         bond)
        ifcfg_interfaces_map[bond] = bond_data
        slaves_data = "SLAVE=yes\nMASTER=%s\n" % bond
        for slave in bond_slaves:
            if slave in ifcfg_interfaces_map:
                ifcfg_interfaces_map[slave] = ifcfg_interfaces_map[slave] +\
                                              slaves_data
            else:
                slave_data = "%s%sDEVICE=%s\n" % (COMMON_IFCFG_DATA,
                                                  slaves_data, slave)
                ifcfg_interfaces_map[slave] = slave_data


def configure_ovs_bridges(ovs_bridges):
    global ifcfg_interfaces_map
    logger.info("Configuring ovs bridges..")
    for ovs_bridge in ovs_bridges:
        # implement ifcfg file for ovs bridge
        bridge = ovs_bridge.get("name")
        ovs_ports = ovs_bridge.get("ports")
        bridge_data = "%(data)s DEVICE=%(name)s\nDEVICETYPE=ovs\n" \
                      "TYPE=OVSBridge\nOVS_EXTRA=\"set bridge %(name)s" \
                      " fail_mode=standalone -- del-controller %(name)s\"\n"\
                      % ({"data": COMMON_IFCFG_DATA, "name": bridge})
        ifcfg_interfaces_map[bridge] = bridge_data

        # implement ifcfg file for ovs ports
        port_data = "DEVICETYPE=ovs\nTYPE=OVSPort\nOVS_BRIDGE=%s\n" % bridge
        for port in ovs_ports:
            if port in ifcfg_interfaces_map:
                ifcfg_interfaces_map[port] = ifcfg_interfaces_map[port] +\
                                             port_data
            else:
                ovs_port_data = "%s%sDEVICE=%s" % (COMMON_IFCFG_DATA,
                                                   port_data, port)
                ifcfg_interfaces_map[port] = ovs_port_data


def bind_vfs(sriov_bind_pci_list=None):
    logger.info("Binding sriov vfs..")
    if not sriov_bind_pci_list:
        sriov_bind_pci_list = get_sriov_bind_pci_list()
    for vf_pci in sriov_bind_pci_list:
        vf_pci_driver_path = VF_PCI_PATH % {"vf_pci": vf_pci}
        if not os.path.exists(vf_pci_driver_path):
            try:
                write_config(MLNX_BIND_FILE_PATH, "%s" % vf_pci)
                logger.debug("Vf %s has been bound" % vf_pci)
            except IOError as e:
                logger.error("Failed to bind vf %s\n%s" % (vf_pci, str(e)))


def configure_sriov_bind_service():
    logger.info("Configuring sriov_bind service..")
    write_config(SRIOV_BIND_SERVICE_FILE,
                 SRIOV_BIND_SERVICE_CONTENT)
    run_command('systemctl', 'enable', 'sriov_bind')


def enable_hw_offloaded(hw_offload_enabled=False):
    logger.info("Enabling hardware offload for openvswitch..")
    try:
        run_command('/usr/bin/ovs-vsctl', 'set', 'Open_Vswitch', '.',
                    'other_config:hw-offload=%s' % hw_offload_enabled)
    except Exception as e:
        logger.error("Failed to set hardware offload to %s\n%s" %
                     (hw_offload_enabled, str(e)))
        raise e
    try:
        run_command('systemctl', 'restart', 'openvswitch')
    except Exception as e:
        logger.error("Failed to restart openvswitch\n%s" % str(e))
        raise e


def write_ifcfg_files(ifcfg_interfaces_map):
    logger.info("Writing ifcfg files for all net devices")
    for interface, ifcfg_data in ifcfg_interfaces_map.items():
        write_config(ifcfg_config_path(interface), ifcfg_data)


def if_down_interface(device):
    logger.info("Running /sbin/ifdown %s" % device)
    try:
        run_command('/sbin/ifdown', device)
    except Exception as e:
        logger.error("Failed to ifdown %s" % (device, str(e)))
        raise e


def if_up_interface(device):
    logger.info("Running /sbin/ifup %s" % device)
    try:
        run_command('/sbin/ifup', device)
    except Exception as e:
        logger.error("Failed to ifup  %s" % (device, str(e)))
        raise e


def bring_interfaces_up(net_interfaces_list):
    logger.info("Bringing interfaces down")
    for interface in net_interfaces_list:
        if_down_interface(interface)
    logger.info("Bringing interfaces up")
    for interface in net_interfaces_list:
        if_up_interface(interface)


def parse_version(version):
    version_major = 0
    version_minor = 0
    try:
        version_split = str(version).split('.')
        version_major = int(version_split[0])
        version_minor = int(version_split[1])
    except Exception as err:
        logger.error("configVersion is not provied in config.yaml file or"
                     "it's incorrect. Please provide configVersion as X.X\n%s"
                     % str(err))
        raise err
    return version_major, version_minor


def validate_config(config):
    # Validate_config is just a quick validation indicates if the user has
    # typo or missing mandatory prams
    # TODO:
    # - Define a schema for the configuration file
    # - Validate all params data type
    # - Notify the user with unused params

    sriov_pfs_list = []
    bonds_list = []
    conf_version = config.get("configVersion")
    conf_version_major, conf_version_minor = parse_version(conf_version)
    if conf_version_major > CONF_VERSION_MAJOR:
        err = "Provided configuration version is not supported. Exiting.."
        logger.error(err)
        raise(RuntimeError(err))
    if conf_version_minor > CONF_VERSION_MINOR:
        logger.debug("Provided configuration version newer, new functionality"
                     " may not be handled by this script")

    for sriov_pf in config.get("pfs"):
        if sriov_pf.get("name"):
            sriov_pfs_list.append(sriov_pf.get("name"))
        else:
            err = "sriov pf name must be provided"
            logger.error(err)
            raise ValueError(err)
        try:
            if int(sriov_pf.get("numOfVfs")):
                continue
        except ValueError as value_err:
            logger.error("numOfVfs for %s must be number" %
                         sriov_pf.get("name"))
            raise value_err
        except TypeError as type_err:
            logger.error("numOfVfs for %s must be provided" %
                         sriov_pf.get("name"))
    for bond in config.get("linuxBonds"):
        if bond.get("name"):
            bonds_list.append(bond.get("name"))
        else:
            err = "bond name must be provided"
            logger.error(err)
            raise ValueError(err)
        if not bond.get("bondingOptions"):
            err = "bondingOptions must be provided for bond %s" %\
                  bond.get("name")
            logger.error(err)
            raise ValueError(err)
        if (bond.get("slaves") and
                (set(bond.get("slaves")).issubset(set(sriov_pfs_list)))):
            continue
        else:
            err = "slaves of bond %s must be list of sriov_pfs" % \
                  bond.get("name")
            logger.error(err)
            raise ValueError(err)
    for bridge in config.get("ovsBridges"):
        if not bridge.get("name"):
            err = "bridge name must be provided"
            logger.error(err)
            raise ValueError(err)
        if (bridge.get("ports") and
                (set(bridge.get("ports")).issubset(set(sriov_pfs_list +
                                                   bonds_list)))):
            continue
        else:
            err = "ports of bridge %s must be list of sriov_pfs or bonds" % \
                  bridge.get("name")
            logger.error(err)
            raise ValueError(err)


def parse_opts(argv):
    parser = argparse.ArgumentParser(
        description='SR-IOV, OVS and network configuration service'
        'for switchdev and VF-LAG configuration')

    parser.add_argument(
        '--sriov_bind',
        action="store_true",
        help="Do sriov vfs bind for sriov_bind service in reboot",
        required=False)

    parser.add_argument(
        '--sriov_config',
        action="store_true",
        help="Do sriov configuration for sriov_config service in reboot",
        required=False)

    parser.add_argument(
        '-v', '--version',
        action='version',
        version=VERSION)

    opts = parser.parse_args(argv[1:])

    return opts


def main(argv=sys.argv):
    opts = parse_opts(argv)
    config = get_config()
    validate_config(config)
    sriov_pfs = config.get("pfs")
    bonds = config.get("linuxBonds")
    bridges = config.get("ovsBridges")
    hw_offload_enabled = config.get("hwOffloadEnabled")

    if (not opts.sriov_config and not opts.sriov_bind):
        # Configure sriov pfs
        configure_sriov_pfs(sriov_pfs)
        configure_sriov_config_service()

        # Configure linux bonds
        configure_linux_bonds(bonds)

        # Configure ovs bridges
        configure_ovs_bridges(bridges)

        # Enable hardware offload
        if hw_offload_enabled is not None:
            enable_hw_offloaded(hw_offload_enabled)

        # Write ifcfg files
        write_ifcfg_files(ifcfg_interfaces_map)

        # Bring interfaces up
        bring_interfaces_up(ifcfg_interfaces_map.keys())

        # Bind vfs
        bind_vfs(mlnx_vfs_pci_list)
        configure_sriov_bind_service()
    else:
        if opts.sriov_config:
            # Configure sriov pfs
            configure_sriov_pfs(sriov_pfs, True)

        if opts.sriov_bind:
            # Bind vfs
            bind_vfs()


if __name__ == '__main__':
    main(sys.argv)
